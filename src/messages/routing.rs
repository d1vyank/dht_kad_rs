// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]

//! Generated file from `routing.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_0_0_PRE;

#[derive(PartialEq,Clone,Default)]
#[derive(serde::Serialize, serde::Deserialize)]
pub struct Message {
    // message fields
    ///  defines what type of message it is.
    pub field_type: ::protobuf::ProtobufEnumOrUnknown<message::MessageType>,
    ///  Used to specify the key associated with this message.
    pub key: ::std::vec::Vec<u8>,
    pub value: ::std::vec::Vec<u8>,
    pub closerPeers: ::protobuf::RepeatedField<message::Peer>,
    pub myself: ::protobuf::SingularPtrField<message::Peer>,
    pub code: ::protobuf::ProtobufEnumOrUnknown<message::ErrorCode>,
    // special fields
    #[serde(skip)]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[serde(skip)]
    pub cached_size: ::protobuf::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Message {
    fn default() -> &'a Message {
        <Message as ::protobuf::Message>::default_instance()
    }
}

impl Message {
    pub fn new() -> Message {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Message {
    fn is_initialized(&self) -> bool {
        for v in &self.closerPeers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.myself {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.field_type = is.read_enum_or_unknown()?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.closerPeers)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into::<message::Peer, _>(wire_type, is, &mut self.myself)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.code = is.read_enum_or_unknown()?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != ::protobuf::ProtobufEnumOrUnknown::new(message::MessageType::STORE) {
            my_size += ::protobuf::rt::enum_or_unknown_size(1, self.field_type);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.value);
        }
        for value in &self.closerPeers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.myself.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.code != ::protobuf::ProtobufEnumOrUnknown::new(message::ErrorCode::OK) {
            my_size += ::protobuf::rt::enum_or_unknown_size(6, self.code);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != ::protobuf::ProtobufEnumOrUnknown::new(message::MessageType::STORE) {
            os.write_enum(1, ::protobuf::ProtobufEnumOrUnknown::value(&self.field_type))?;
        }
        if !self.key.is_empty() {
            os.write_bytes(2, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(3, &self.value)?;
        }
        for v in &self.closerPeers {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.myself.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if self.code != ::protobuf::ProtobufEnumOrUnknown::new(message::ErrorCode::OK) {
            os.write_enum(6, ::protobuf::ProtobufEnumOrUnknown::value(&self.code))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Message {
        Message::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::rt::make_simple_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeEnumOrUnknown<message::MessageType>>(
                "type",
                |m: &Message| { &m.field_type },
                |m: &mut Message| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::rt::make_simple_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes>(
                "key",
                |m: &Message| { &m.key },
                |m: &mut Message| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::rt::make_simple_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes>(
                "value",
                |m: &Message| { &m.value },
                |m: &mut Message| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::rt::make_repeated_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<message::Peer>>(
                "closerPeers",
                |m: &Message| { &m.closerPeers },
                |m: &mut Message| { &mut m.closerPeers },
            ));
            fields.push(::protobuf::reflect::rt::make_option_accessor::<_, ::protobuf::reflect::types::ProtobufTypeMessage<message::Peer>, _>(
                "myself",
                |m: &Message| { &m.myself },
                |m: &mut Message| { &mut m.myself },
            ));
            fields.push(::protobuf::reflect::rt::make_simple_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeEnumOrUnknown<message::ErrorCode>>(
                "code",
                |m: &Message| { &m.code },
                |m: &mut Message| { &mut m.code },
            ));
            ::protobuf::reflect::MessageDescriptor::new::<Message>(
                "Message",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Message {
        static instance: ::protobuf::rt::Lazy<Message> = ::protobuf::rt::Lazy::INIT;
        instance.get(Message::new)
    }
}

impl ::protobuf::Clear for Message {
    fn clear(&mut self) {
        self.field_type = ::protobuf::ProtobufEnumOrUnknown::new(message::MessageType::STORE);
        self.key.clear();
        self.value.clear();
        self.closerPeers.clear();
        self.myself.clear();
        self.code = ::protobuf::ProtobufEnumOrUnknown::new(message::ErrorCode::OK);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Message {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Message {
}

/// Nested message and enums of message `Message`
pub mod message {
    #[derive(PartialEq,Clone,Default)]
    #[derive(serde::Serialize, serde::Deserialize)]
    pub struct Peer {
        // message fields
        ///  ID of a given peer.
        pub id: ::std::vec::Vec<u8>,
        ///  address for a given peer
        pub addrs: ::std::vec::Vec<u8>,
        // special fields
        #[serde(skip)]
        pub unknown_fields: ::protobuf::UnknownFields,
        #[serde(skip)]
        pub cached_size: ::protobuf::rt::CachedSize,
    }

    impl<'a> ::std::default::Default for &'a Peer {
        fn default() -> &'a Peer {
            <Peer as ::protobuf::Message>::default_instance()
        }
    }

    impl Peer {
        pub fn new() -> Peer {
            ::std::default::Default::default()
        }
    }

    impl ::protobuf::Message for Peer {
        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            while !is.eof()? {
                let (field_number, wire_type) = is.read_tag_unpack()?;
                match field_number {
                    1 => {
                        ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.id)?;
                    },
                    2 => {
                        ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.addrs)?;
                    },
                    _ => {
                        ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u32 {
            let mut my_size = 0;
            if !self.id.is_empty() {
                my_size += ::protobuf::rt::bytes_size(1, &self.id);
            }
            if !self.addrs.is_empty() {
                my_size += ::protobuf::rt::bytes_size(2, &self.addrs);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
            self.cached_size.set(my_size);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
            if !self.id.is_empty() {
                os.write_bytes(1, &self.id)?;
            }
            if !self.addrs.is_empty() {
                os.write_bytes(2, &self.addrs)?;
            }
            os.write_unknown_fields(self.get_unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn get_cached_size(&self) -> u32 {
            self.cached_size.get()
        }

        fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
            &self.unknown_fields
        }

        fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
            &mut self.unknown_fields
        }

        fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
            Self::descriptor_static()
        }

        fn new() -> Peer {
            Peer::new()
        }

        fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::rt::make_simple_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes>(
                    "id",
                    |m: &Peer| { &m.id },
                    |m: &mut Peer| { &mut m.id },
                ));
                fields.push(::protobuf::reflect::rt::make_simple_field_accessor::<_, ::protobuf::reflect::types::ProtobufTypeBytes>(
                    "addrs",
                    |m: &Peer| { &m.addrs },
                    |m: &mut Peer| { &mut m.addrs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Peer>(
                    "Message.Peer",
                    fields,
                    super::file_descriptor_proto()
                )
            })
        }

        fn default_instance() -> &'static Peer {
            static instance: ::protobuf::rt::Lazy<Peer> = ::protobuf::rt::Lazy::INIT;
            instance.get(Peer::new)
        }
    }

    impl ::protobuf::Clear for Peer {
        fn clear(&mut self) {
            self.id.clear();
            self.addrs.clear();
            self.unknown_fields.clear();
        }
    }

    impl ::std::fmt::Debug for Peer {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Peer {
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    #[derive(serde::Serialize, serde::Deserialize)]
    pub enum MessageType {
        STORE = 0,
        FIND_VALUE = 1,
        FIND_NODE = 2,
        PING = 3,
    }

    impl ::protobuf::ProtobufEnum for MessageType {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<MessageType> {
            match value {
                0 => ::std::option::Option::Some(MessageType::STORE),
                1 => ::std::option::Option::Some(MessageType::FIND_VALUE),
                2 => ::std::option::Option::Some(MessageType::FIND_NODE),
                3 => ::std::option::Option::Some(MessageType::PING),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [MessageType] = &[
                MessageType::STORE,
                MessageType::FIND_VALUE,
                MessageType::FIND_NODE,
                MessageType::PING,
            ];
            values
        }

        fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new::<MessageType>("Message.MessageType", super::file_descriptor_proto())
            })
        }
    }

    impl ::std::default::Default for MessageType {
        fn default() -> Self {
            MessageType::STORE
        }
    }

    impl ::protobuf::reflect::ProtobufValue for MessageType {
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    #[derive(serde::Serialize, serde::Deserialize)]
    pub enum ErrorCode {
        OK = 0,
        INTERNAL_ERROR = 1,
        NOT_FOUND = 2,
        BAD_REQUEST = 3,
    }

    impl ::protobuf::ProtobufEnum for ErrorCode {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ErrorCode> {
            match value {
                0 => ::std::option::Option::Some(ErrorCode::OK),
                1 => ::std::option::Option::Some(ErrorCode::INTERNAL_ERROR),
                2 => ::std::option::Option::Some(ErrorCode::NOT_FOUND),
                3 => ::std::option::Option::Some(ErrorCode::BAD_REQUEST),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [ErrorCode] = &[
                ErrorCode::OK,
                ErrorCode::INTERNAL_ERROR,
                ErrorCode::NOT_FOUND,
                ErrorCode::BAD_REQUEST,
            ];
            values
        }

        fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::INIT;
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new::<ErrorCode>("Message.ErrorCode", super::file_descriptor_proto())
            })
        }
    }

    impl ::std::default::Default for ErrorCode {
        fn default() -> Self {
            ErrorCode::OK
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ErrorCode {
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rrouting.proto\x12\nrouting.pb\"\xc1\x03\n\x07Message\x123\n\x04type\
    \x18\x01\x20\x01(\x0e2\x1f.routing.pb.Message.MessageTypeR\x04type\x12\
    \x10\n\x03key\x18\x02\x20\x01(\x0cR\x03key\x12\x14\n\x05value\x18\x03\
    \x20\x01(\x0cR\x05value\x12:\n\x0bcloserPeers\x18\x04\x20\x03(\x0b2\x18.\
    routing.pb.Message.PeerR\x0bcloserPeers\x120\n\x06myself\x18\x05\x20\x01\
    (\x0b2\x18.routing.pb.Message.PeerR\x06myself\x121\n\x04code\x18\x06\x20\
    \x01(\x0e2\x1d.routing.pb.Message.ErrorCodeR\x04code\x1a,\n\x04Peer\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\x0cR\x02id\x12\x14\n\x05addrs\x18\x02\x20\
    \x01(\x0cR\x05addrs\"A\n\x0bMessageType\x12\t\n\x05STORE\x10\0\x12\x0e\n\
    \nFIND_VALUE\x10\x01\x12\r\n\tFIND_NODE\x10\x02\x12\x08\n\x04PING\x10\
    \x03\"G\n\tErrorCode\x12\x06\n\x02OK\x10\0\x12\x12\n\x0eINTERNAL_ERROR\
    \x10\x01\x12\r\n\tNOT_FOUND\x10\x02\x12\x0f\n\x0bBAD_REQUEST\x10\x03J\
    \xd6\t\n\x06\x12\x04\0\0(\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\
    \x01\x02\x12\x03\x01\x08\x12\n\n\n\x02\x04\0\x12\x04\x04\0(\x01\n\n\n\
    \x03\x04\0\x01\x12\x03\x04\x08\x0f\n\x0c\n\x04\x04\0\x04\0\x12\x04\x05\
    \x08\n\t\n\x0c\n\x05\x04\0\x04\0\x01\x12\x03\x05\r\x18\n\r\n\x06\x04\0\
    \x04\0\x02\0\x12\x03\x06\x10\x1a\n\x0e\n\x07\x04\0\x04\0\x02\0\x01\x12\
    \x03\x06\x10\x15\n\x0e\n\x07\x04\0\x04\0\x02\0\x02\x12\x03\x06\x18\x19\n\
    \r\n\x06\x04\0\x04\0\x02\x01\x12\x03\x07\x10\x1f\n\x0e\n\x07\x04\0\x04\0\
    \x02\x01\x01\x12\x03\x07\x10\x1a\n\x0e\n\x07\x04\0\x04\0\x02\x01\x02\x12\
    \x03\x07\x1d\x1e\n\r\n\x06\x04\0\x04\0\x02\x02\x12\x03\x08\x10\x1e\n\x0e\
    \n\x07\x04\0\x04\0\x02\x02\x01\x12\x03\x08\x10\x19\n\x0e\n\x07\x04\0\x04\
    \0\x02\x02\x02\x12\x03\x08\x1c\x1d\n\r\n\x06\x04\0\x04\0\x02\x03\x12\x03\
    \t\x10\x19\n\x0e\n\x07\x04\0\x04\0\x02\x03\x01\x12\x03\t\x10\x14\n\x0e\n\
    \x07\x04\0\x04\0\x02\x03\x02\x12\x03\t\x17\x18\n\x0c\n\x04\x04\0\x04\x01\
    \x12\x04\x0c\x08\x11\t\n\x0c\n\x05\x04\0\x04\x01\x01\x12\x03\x0c\r\x16\n\
    \r\n\x06\x04\0\x04\x01\x02\0\x12\x03\r\x10\x17\n\x0e\n\x07\x04\0\x04\x01\
    \x02\0\x01\x12\x03\r\x10\x12\n\x0e\n\x07\x04\0\x04\x01\x02\0\x02\x12\x03\
    \r\x15\x16\n\r\n\x06\x04\0\x04\x01\x02\x01\x12\x03\x0e\x10#\n\x0e\n\x07\
    \x04\0\x04\x01\x02\x01\x01\x12\x03\x0e\x10\x1e\n\x0e\n\x07\x04\0\x04\x01\
    \x02\x01\x02\x12\x03\x0e!\"\n\r\n\x06\x04\0\x04\x01\x02\x02\x12\x03\x0f\
    \x10\x1e\n\x0e\n\x07\x04\0\x04\x01\x02\x02\x01\x12\x03\x0f\x10\x19\n\x0e\
    \n\x07\x04\0\x04\x01\x02\x02\x02\x12\x03\x0f\x1c\x1d\n\r\n\x06\x04\0\x04\
    \x01\x02\x03\x12\x03\x10\x10\x20\n\x0e\n\x07\x04\0\x04\x01\x02\x03\x01\
    \x12\x03\x10\x10\x1b\n\x0e\n\x07\x04\0\x04\x01\x02\x03\x02\x12\x03\x10\
    \x1e\x1f\n\x0c\n\x04\x04\0\x03\0\x12\x04\x13\x08\x19\t\n\x0c\n\x05\x04\0\
    \x03\0\x01\x12\x03\x13\x10\x14\n$\n\x06\x04\0\x03\0\x02\0\x12\x03\x15\
    \x10\x1d\x1a\x15\x20ID\x20of\x20a\x20given\x20peer.\n\n\x0f\n\x07\x04\0\
    \x03\0\x02\0\x04\x12\x04\x15\x10\x13\x16\n\x0e\n\x07\x04\0\x03\0\x02\0\
    \x05\x12\x03\x15\x10\x15\n\x0e\n\x07\x04\0\x03\0\x02\0\x01\x12\x03\x15\
    \x16\x18\n\x0e\n\x07\x04\0\x03\0\x02\0\x03\x12\x03\x15\x1b\x1c\n)\n\x06\
    \x04\0\x03\0\x02\x01\x12\x03\x18\x10\x20\x1a\x1a\x20address\x20for\x20a\
    \x20given\x20peer\n\n\x0f\n\x07\x04\0\x03\0\x02\x01\x04\x12\x04\x18\x10\
    \x15\x1d\n\x0e\n\x07\x04\0\x03\0\x02\x01\x05\x12\x03\x18\x10\x15\n\x0e\n\
    \x07\x04\0\x03\0\x02\x01\x01\x12\x03\x18\x16\x1b\n\x0e\n\x07\x04\0\x03\0\
    \x02\x01\x03\x12\x03\x18\x1e\x1f\n2\n\x04\x04\0\x02\0\x12\x03\x1c\x08\
    \x1d\x1a%\x20defines\x20what\x20type\x20of\x20message\x20it\x20is.\n\n\r\
    \n\x05\x04\0\x02\0\x04\x12\x04\x1c\x08\x19\t\n\x0c\n\x05\x04\0\x02\0\x06\
    \x12\x03\x1c\x08\x13\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03\x1c\x14\x18\n\
    \x0c\n\x05\x04\0\x02\0\x03\x12\x03\x1c\x1b\x1c\nD\n\x04\x04\0\x02\x01\
    \x12\x03\x1f\x08\x16\x1a7\x20Used\x20to\x20specify\x20the\x20key\x20asso\
    ciated\x20with\x20this\x20message.\n\n\r\n\x05\x04\0\x02\x01\x04\x12\x04\
    \x1f\x08\x1c\x1d\n\x0c\n\x05\x04\0\x02\x01\x05\x12\x03\x1f\x08\r\n\x0c\n\
    \x05\x04\0\x02\x01\x01\x12\x03\x1f\x0e\x11\n\x0c\n\x05\x04\0\x02\x01\x03\
    \x12\x03\x1f\x14\x15\n\x0b\n\x04\x04\0\x02\x02\x12\x03!\x08\x18\n\r\n\
    \x05\x04\0\x02\x02\x04\x12\x04!\x08\x1f\x16\n\x0c\n\x05\x04\0\x02\x02\
    \x05\x12\x03!\x08\r\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03!\x0e\x13\n\x0c\
    \n\x05\x04\0\x02\x02\x03\x12\x03!\x16\x17\n\x0b\n\x04\x04\0\x02\x03\x12\
    \x03#\x08&\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03#\x08\x10\n\x0c\n\x05\
    \x04\0\x02\x03\x06\x12\x03#\x11\x15\n\x0c\n\x05\x04\0\x02\x03\x01\x12\
    \x03#\x16!\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03#$%\n\x0b\n\x04\x04\0\
    \x02\x04\x12\x03%\x08\x18\n\r\n\x05\x04\0\x02\x04\x04\x12\x04%\x08#&\n\
    \x0c\n\x05\x04\0\x02\x04\x06\x12\x03%\x08\x0c\n\x0c\n\x05\x04\0\x02\x04\
    \x01\x12\x03%\r\x13\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x03%\x16\x17\n\x0b\
    \n\x04\x04\0\x02\x05\x12\x03'\x08\x1b\n\r\n\x05\x04\0\x02\x05\x04\x12\
    \x04'\x08%\x18\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x03'\x08\x11\n\x0c\n\
    \x05\x04\0\x02\x05\x01\x12\x03'\x12\x16\n\x0c\n\x05\x04\0\x02\x05\x03\
    \x12\x03'\x19\x1ab\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
